"""
Production Mobile Automation Script - Task 0
Generated by Enhanced Agent 2
Task: Create an Outlook account with name Krishna Kumar and DOB 20 Sep 2000
Platform: Mobile (Android)
Generated: 2025-09-20T14:14:36.497514+00:00
"""

import logging
import time
import json
import random
import subprocess
from datetime import datetime
from pathlib import Path
from typing import Optional, Dict, Any, List

# Mobile automation imports
from appium import webdriver
from appium.options.android import UiAutomator2Options
from appium.webdriver.common.appiumby import AppiumBy
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, StaleElementReferenceException
from selenium.webdriver.common.actions.action_builder import ActionBuilder
from selenium.webdriver.common.actions.pointer_input import PointerInput
from selenium.webdriver.common.actions import interaction

# OCR and image processing
import pytesseract
from PIL import Image
import cv2
import numpy as np

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('automation_execution.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

class DynamicDeviceManager:
    """Handles dynamic Android device detection and management"""
    
    def __init__(self):
        self.device_info = None
        self.capabilities = None
    
    def detect_connected_devices(self) -> List[Dict[str, Any]]:
        """Detect all connected Android devices"""
        devices = []
        try:
            result = subprocess.run(
                ["adb", "devices", "-l"], 
                capture_output=True, 
                text=True, 
                timeout=15
            )
            
            if result.returncode == 0:
                lines = result.stdout.strip().split('\n')[1:]  # Skip header
                for line in lines:
                    if line.strip() and 'device' in line:
                        parts = line.split()
                        if len(parts) >= 2 and parts[1] == 'device':
                            device_id = parts[0]
                            device_info = self.get_device_details(device_id)
                            if device_info:
                                devices.append(device_info)
                
                logger.info(f"‚úÖ Detected {len(devices)} connected Android devices")
                return devices
                
        except Exception as e:
            logger.error(f"‚ùå Device detection failed: {str(e)}")
            return []
    
    def get_device_details(self, device_id: str) -> Optional[Dict[str, Any]]:
        """Get detailed information about a specific device"""
        try:
            device_info = {
                "device_id": device_id,
                "device_name": "Android Device",
                "is_emulator": device_id.startswith("emulator-"),
                "api_level": None,
                "screen_resolution": None,
                "manufacturer": None,
                "model": None,
                "android_version": None
            }
            
            # Get device properties
            properties = [
                ("ro.build.version.release", "android_version"),
                ("ro.build.version.sdk", "api_level"),
                ("ro.product.manufacturer", "manufacturer"),
                ("ro.product.model", "model")
            ]
            
            for prop, key in properties:
                try:
                    result = subprocess.run(
                        ["adb", "-s", device_id, "shell", "getprop", prop],
                        capture_output=True, text=True, timeout=10
                    )
                    if result.returncode == 0:
                        device_info[key] = result.stdout.strip()
                except Exception:
                    continue
            
            # Get screen resolution
            try:
                result = subprocess.run(
                    ["adb", "-s", device_id, "shell", "wm", "size"],
                    capture_output=True, text=True, timeout=10
                )
                if result.returncode == 0:
                    import re
                    match = re.search(r'(\d+)x(\d+)', result.stdout)
                    if match:
                        device_info["screen_resolution"] = f"{match.group(1)}x{match.group(2)}"
            except Exception:
                pass
            
            # Set display name
            if device_info["manufacturer"] and device_info["model"]:
                device_info["device_name"] = f"{device_info['manufacturer']} {device_info['model']}"
            elif device_info["is_emulator"]:
                device_info["device_name"] = f"Android Emulator ({device_id})"
            
            return device_info
            
        except Exception as e:
            logger.error(f"‚ùå Failed to get device details for {device_id}: {str(e)}")
            return None
    
    def select_best_device(self) -> Optional[Dict[str, Any]]:
        """Select the best available device for automation"""
        devices = self.detect_connected_devices()
        if not devices:
            logger.error("‚ùå No connected Android devices found")
            return None
        
        # Prefer real devices over emulators
        real_devices = [d for d in devices if not d['is_emulator']]
        selected = real_devices[0] if real_devices else devices[0]
        
        self.device_info = selected
        logger.info(f"‚úÖ Selected device: {selected['device_name']} ({selected['device_id']})")
        return selected
    
    def create_capabilities(self) -> Dict[str, Any]:
        """Create Appium capabilities for the selected device"""
        if not self.device_info:
            raise Exception("No device selected")
        
        capabilities = {
            "platformName": "Android",
            "deviceName": self.device_info["device_name"],
            "udid": self.device_info["device_id"],
            "automationName": "UiAutomator2",
            "noReset": False,
            "fullReset": False,
            "newCommandTimeout": 300,
            "unicodeKeyboard": True,
            "resetKeyboard": True,
            "autoGrantPermissions": True,
            "systemPort": 8200 + random.randint(1, 99),  # Dynamic port
            "enforceXPath1": True,
            "appWaitTimeout": 30000
        }
        
        if self.device_info.get("android_version"):
            capabilities["platformVersion"] = self.device_info["android_version"]
        
        self.capabilities = capabilities
        return capabilities

class ProductionMobileAutomation:
    """Production-ready mobile automation with advanced features"""
    
    def __init__(self):
        self.driver = None
        self.device_manager = DynamicDeviceManager()
        self.ocr_logs_dir = Path("ocr_logs")
        self.ocr_logs_dir.mkdir(exist_ok=True)
        self.screen_size = None
        self.step_results = []
        
        # User data for automation
        self.user_data = {'name': 'Krishna Kumar', 'dob': '20/02/2000', 'email': 'krishna.kumar@example.com', 'password': 'SecurePass123!'}
    
    def setup_driver(self) -> bool:
        """Setup Appium driver with dynamic device detection"""
        try:
            logger.info("üöÄ Setting up mobile automation driver...")
            
            # Select best device
            device = self.device_manager.select_best_device()
            if not device:
                raise Exception("No suitable device found")
            
            # Create capabilities
            capabilities = self.device_manager.create_capabilities()
            logger.info(f"üì± Device capabilities: {json.dumps(capabilities, indent=2)}")
            
            # Initialize driver
            self.driver = webdriver.Remote(
                "http://localhost:4723", 
                options=UiAutomator2Options().load_capabilities(capabilities)
            )
            self.driver.implicitly_wait(10)
            
            # Get screen size
            self.screen_size = self.driver.get_window_size()
            logger.info(f"üì± Screen resolution: {self.screen_size['width']}x{self.screen_size['height']}")
            
            # Update driver settings for better stability
            self.driver.update_settings({
                "enforceXPath1": True,
                "waitForIdleTimeout": 1000,
                "waitForSelectorTimeout": 5000
            })
            
            logger.info("‚úÖ Mobile driver initialized successfully")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Driver setup failed: {str(e)}")
            return False
    
    def enhanced_screenshot_with_ocr(self, step_name: str) -> Tuple[str, str]:
        """Take screenshot with enhanced OCR processing"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        screenshot_path = self.ocr_logs_dir / f"{step_name}_{timestamp}.png"
        ocr_path = self.ocr_logs_dir / f"{step_name}_{timestamp}.txt"
        
        if not self.driver:
            return "", ""
        
        try:
            # Take screenshot
            self.driver.save_screenshot(str(screenshot_path))
            
            # Enhanced OCR processing
            image = cv2.imread(str(screenshot_path))
            # Preprocess image for better OCR
            gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
            
            # Apply different OCR techniques
            ocr_results = []
            
            # Standard OCR
            standard_text = pytesseract.image_to_string(gray, config='--psm 6')
            ocr_results.append(("Standard OCR", standard_text))
            
            # OCR with different PSM modes for better text detection
            for psm in [3, 6, 8, 11]:
                try:
                    psm_text = pytesseract.image_to_string(gray, config=f'--psm {psm}')
                    if psm_text.strip() and psm_text != standard_text:
                        ocr_results.append((f"PSM {psm} OCR", psm_text))
                except:
                    continue
            
            # Save comprehensive OCR result
            with open(ocr_path, 'w', encoding='utf-8') as f:
                f.write(f"OCR Analysis for {step_name}\n")
                f.write(f"Timestamp: {timestamp}\n")
                f.write(f"Screenshot: {screenshot_path}\n")
                f.write(f"Device: {self.device_manager.device_info['device_name'] if self.device_manager.device_info else 'Unknown'}\n")
                f.write(f"Screen Size: {self.screen_size}\n")
                f.write("=" * 50 + "\n")
                
                for method, text in ocr_results:
                    f.write(f"{method}:\n")
                    f.write(f"{text}\n")
                    f.write("-" * 30 + "\n")
            
            # Return best OCR result (usually the first one)
            best_ocr = ocr_results[0][1] if ocr_results else ""
            
            logger.info(f"üì∏ Screenshot and OCR saved: {screenshot_path}")
            return str(screenshot_path), best_ocr
            
        except Exception as e:
            logger.error(f"‚ùå Screenshot/OCR failed: {str(e)}")
            return str(screenshot_path) if 'screenshot_path' in locals() else "", ""
    
    def smart_element_finder(self, locator_strategies: List[Dict[str, str]], wait_time: int = 10) -> Optional[Any]:
        """Smart element finding with multiple strategies"""
        wait = WebDriverWait(self.driver, wait_time)
        
        for strategy in locator_strategies:
            try:
                by_type = strategy.get("by", "id")
                value = strategy.get("value", "")
                
                # Map string locator types to AppiumBy constants
                by_mapping = {
                    "id": AppiumBy.ID,
                    "xpath": AppiumBy.XPATH,
                    "class_name": AppiumBy.CLASS_NAME,
                    "accessibility_id": AppiumBy.ACCESSIBILITY_ID,
                    "android_uiautomator": AppiumBy.ANDROID_UIAUTOMATOR,
                    "name": AppiumBy.NAME
                }
                
                locator = by_mapping.get(by_type, AppiumBy.XPATH)
                element = wait.until(EC.presence_of_element_located((locator, value)))
                
                logger.info(f"‚úÖ Element found using {by_type}: {value}")
                return element
                
            except TimeoutException:
                logger.warning(f"‚ö†Ô∏è Element not found with strategy {strategy['by']}: {strategy['value']}")
                continue
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Error with locator strategy {strategy}: {str(e)}")
                continue
        
        logger.error("‚ùå Element not found with any strategy")
        return None
    
    def smart_tap(self, x: int, y: int) -> bool:
        """Smart tap with coordinate validation"""
        try:
            # Validate coordinates
            if x < 0 or y < 0 or x > self.screen_size["width"] or y > self.screen_size["height"]:
                logger.warning(f"‚ö†Ô∏è Coordinates out of bounds: ({x}, {y})")
                return False
            
            self.driver.tap([(x, y)], 100)
            logger.info(f"‚úÖ Tapped at coordinates: ({x}, {y})")
            time.sleep(1)  # Brief pause
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Tap failed at ({x}, {y}): {str(e)}")
            return False
    
    def safe_send_keys(self, element, input_text: str, clear_first: bool = True) -> bool:
        """Safe text input with validation"""
        try:
            if clear_first:
                element.clear()
                time.sleep(0.5)
                
            element.send_keys(input_text)
            logger.info(f"‚úÖ Text entered: {input_text[:20]}..." if len(input_text) > 20 else f"‚úÖ Text entered: {input_text}")
            time.sleep(1)
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Text input failed: {str(e)}")
            return False
    
    def run_automation(self) -> bool:
        """Execute the complete automation workflow"""
        workflow_start_time = time.time()
        
        try:
            logger.info("üöÄ Starting production mobile automation...")
            logger.info(f"üìã Task: {'Create an Outlook account with name Krishna Kumar and DOB 20 Sep 2000'}")
            logger.info(f"üë§ User Data: {json.dumps(self.user_data, indent=2)}")
            
            if not self.setup_driver():
                raise Exception("Failed to setup mobile driver")
            
            # Launch Outlook app
            try:
                self.driver.start_activity("com.microsoft.office.outlook", ".MainActivity")
                time.sleep(3)
            except:
                # Try alternative launch methods
                try:
                    self.driver.activate_app("com.microsoft.office.outlook")
                    time.sleep(3)
                    logger.info("‚úÖ Outlook app launched")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è App launch issues: {str(e)}")

            # Save comprehensive results
            execution_time = time.time() - workflow_start_time
            results_summary = {
                "task_id": task_id,
                "instruction": instruction,
                "execution_time": execution_time,
                "execution_timestamp": datetime.utcnow().isoformat(),
                "device_info": self.device_manager.device_info,
                "screen_size": self.screen_size,
                "total_steps": len(self.step_results),
                "completed_steps": len([r for r in self.step_results if r["status"] == "completed"]),
                "failed_steps": len([r for r in self.step_results if r["status"] == "failed"]),
                "success_rate": len([r for r in self.step_results if r["status"] == "completed"]) / len(self.step_results) * 100 if self.step_results else 0,
                "user_data": self.user_data,
                "results": self.step_results
            }
            
            # Save results
            results_path = self.ocr_logs_dir / "automation_results.json"
            with open(results_path, 'w', encoding='utf-8') as f:
                json.dump(results_summary, f, indent=2, ensure_ascii=False)
            
            success_count = results_summary["completed_steps"]
            total_count = results_summary["total_steps"]
            
            logger.info(f"üéØ Automation completed: {success_count}/{total_count} steps successful")
            logger.info(f"‚è±Ô∏è Total execution time: {execution_time:.2f} seconds")
            logger.info(f"üìä Success rate: {results_summary['success_rate']:.1f}%")
            
            return results_summary["success_rate"] >= 70.0  # Consider 70% success rate as overall success
            
        except Exception as e:
            logger.error(f"‚ùå Mobile automation failed: {str(e)}")
            return False
            
        finally:
            if self.driver:
                try:
                    self.driver.quit()
                    logger.info("‚úÖ Mobile driver cleaned up")
                except:
                    pass

if __name__ == "__main__":
    automation = ProductionMobileAutomation()
    success = automation.run_automation()
    
    print("-" * 50)
    print(f"AUTOMATION RESULT: {'SUCCESS' if success else 'FAILED'}")
    print("-" * 50)
    
    exit(0 if success else 1)
